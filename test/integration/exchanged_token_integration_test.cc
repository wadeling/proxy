/* Copyright 2018 Istio Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// The integration tests in this file test the end-to-end behaviour of
// an exchanged token when going through the HTTP filter chains
// (jwt-authn + istio-authn + istio-mixer). Filters pass on processing
// results next filters using the request info through dynamic metadata
// and the results generated by the filters can be observed at the mixer
// backend).

#include "fmt/printf.h"
#include "gmock/gmock.h"
#include "include/istio/utils/attribute_names.h"
#include "mixer/v1/mixer.pb.h"
#include "src/envoy/utils/filter_names.h"
#include "test/integration/http_protocol_integration.h"

using ::google::protobuf::util::error::Code;
using ::testing::Contains;
using ::testing::Not;

namespace Envoy {
namespace {

// An example exchanged token
constexpr char kExchangedToken[] =
    "istio "
    "eyJhbGciOiJSUzI1NiIsImtpZCI6IkRIRmJwb0lVcXJZOHQyenBBMnFYZkNtcjVWTzVaRXI0Un"
    "pIVV8tZW52dlEiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJleGFtcGxlLWF1ZGllbmNlIiwiZW1ha"
    "WwiOiJmb29AZ29vZ2xlLmNvbSIsImV4cCI6NDY5ODM2MTUwOCwiaWF0IjoxNTQ0NzYxNTA4LCJ"
    "pc3MiOiJodHRwczovL2V4YW1wbGUudG9rZW5fc2VydmljZS5jb20iLCJpc3Rpb19hdHRyaWJ1d"
    "GVzIjpbeyJzb3VyY2UuaXAiOiIxMjcuMC4wLjEifV0sImtleTEiOlsidmFsMiIsInZhbDMiXSw"
    "ib3JpZ2luYWxfY2xhaW1zIjp7ImVtYWlsIjoidXNlckBleGFtcGxlLmNvbSIsImlzcyI6Imh0d"
    "HBzOi8vYWNjb3VudHMuZXhhbXBsZS5jb20iLCJzdWIiOiJleGFtcGxlLXN1YmplY3QifSwic3V"
    "iIjoiaHR0cHM6Ly9hY2NvdW50cy5leGFtcGxlLmNvbS8xMjM0NTU2Nzg5MCJ9.mLm9Gmcd748a"
    "nwybiPxGPEuYgJBChqoHkVOvRhQN-H9jMqVKyF-7ynud1CJp5n72VeMB1FzvKAV0ErzSyWQc0i"
    "ofQywG6whYXP6zL-Oc0igUrLDvzb6PuBDkbWOcZrvHkHM4tIYAkF4j880GqMWEP3gGrykziIEY"
    "9g4povquCFSdkLjjyol2-Ge_6MFdayYoeWLLOaMP7tHiPTm_ajioQ4jcz5whBWu3DZWx4IuU5U"
    "IBYlHG_miJZv5zmwwQ60T1_p_sW7zkABJgDhCvu6cHh6g-hZdQvZbATFwMfN8VDzttTjRG8wuL"
    "lkQ1TTOCx5PDv-_gHfQfRWt8Z94HrIJPuQ";

// An example token without original_claims
constexpr char kTokenWithoutOriginalClaims[] =
    "eyJhbGciOiJSUzI1NiIsImtpZCI6IkRIRmJwb0lVcXJZOHQyenBBMnFYZkNtcjVWTzVaRXI0Un"
    "pIVV8tZW52dlEiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJleGFtcGxlLWF1ZGllbmNlIiwiZW1ha"
    "WwiOiJmb29AZ29vZ2xlLmNvbSIsImV4cCI6NDY5ODcyNzc2NiwiaWF0IjoxNTQ1MTI3NzY2LCJ"
    "pc3MiOiJodHRwczovL2V4YW1wbGUudG9rZW5fc2VydmljZS5jb20iLCJpc3Rpb19hdHRyaWJ1d"
    "GVzIjpbeyJzb3VyY2UuaXAiOiIxMjcuMC4wLjEifV0sImtleTEiOlsidmFsMiIsInZhbDMiXSw"
    "ic3ViIjoiaHR0cHM6Ly9hY2NvdW50cy5leGFtcGxlLmNvbS8xMjM0NTU2Nzg5MCJ9.FVskjGxS"
    "cTuNFtKGRnQvQgejgcdPbunCAbXlj_ZYMawrHIYnrMt_Ddw5nOojxQu2zfkwoB004196ozNjDR"
    "ED4jpJA0T6HP7hyTHGbrp6h6Z4dQ_PcmAxdR2_g8GEo-bcJ-CcbATEyBtrDqLtFcgP-ev_ctAo"
    "BQHGp7qMgdpkQIJ07BTT1n6mghPFFCnA__RYWjPUwMLGZs_bOtWxHYbd-bkDSwg4Kbtf5-9oPI"
    "nwJc6oMGMVzdjmJYMadg5GEor5XhgYz3TThPzLlEsxa0loD9eJDBGgdwjA1cLuAGgM7_HgRfg7"
    "8ameSmQgSCsNlFB4k3ODeC-YC62KYdZ5Jdrg2A";

constexpr char kExpectedPrincipal[] =
    "https://accounts.example.com/example-subject";
constexpr char kDestinationNamespace[] = "pod";
constexpr char kDestinationUID[] = "kubernetes://dest.pod";
constexpr char kSourceUID[] = "kubernetes://src.pod";
constexpr char kTelemetryBackend[] = "telemetry-backend";
constexpr char kPolicyBackend[] = "policy-backend";
const std::string kHeaderForExchangedToken = "ingress-authorization";

// Generates basic test request header.
Http::TestHeaderMapImpl BaseRequestHeaders() {
  return Http::TestHeaderMapImpl{{":method", "GET"},
                                 {":path", "/"},
                                 {":scheme", "http"},
                                 {":authority", "host"},
                                 {"x-forwarded-for", "10.0.0.1"}};
}

// Generates test request header with given token.
Http::TestHeaderMapImpl HeadersWithToken(const std::string& header,
                                         const std::string& token) {
  auto headers = BaseRequestHeaders();
  headers.addCopy(header, token);
  return headers;
}

std::string MakeJwtFilterConfig() {
  constexpr char kJwtFilterTemplate[] = R"(
  name: %s
  config:
    rules:
    - issuer: "https://example.token_service.com"
      from_headers:
        - name: ingress-authorization
      local_jwks:
        inline_string: "%s"
    - issuer: "testing-rbac@secure.istio.io"
      local_jwks:
        inline_string: "%s"
    allow_missing_or_failed: true
  )";
  // From
  // https://github.com/istio/istio/blob/master/security/tools/jwt/samples/jwks.json
  constexpr char kJwksInline[] =
      "{ \"keys\":[ "
      "{\"e\":\"AQAB\",\"kid\":\"DHFbpoIUqrY8t2zpA2qXfCmr5VO5ZEr4RzHU_-envvQ\","
      "\"kty\":\"RSA\",\"n\":\"xAE7eB6qugXyCAG3yhh7pkDkT65pHymX-"
      "P7KfIupjf59vsdo91bSP9C8H07pSAGQO1MV"
      "_xFj9VswgsCg4R6otmg5PV2He95lZdHtOcU5DXIg_"
      "pbhLdKXbi66GlVeK6ABZOUW3WYtnNHD-91gVuoeJT_"
      "DwtGGcp4ignkgXfkiEm4sw-4sfb4qdt5oLbyVpmW6x9cfa7vs2WTfURiCrBoUqgBo_-"
      "4WTiULmmHSGZHOjzwa8WtrtOQGsAFjIbno85jp6MnGGGZPYZbDAa_b3y5u-"
      "YpW7ypZrvD8BgtKVjgtQgZhLAGezMt0ua3DRrWnKqTZ0BJ_EyxOGuHJrLsn00fnMQ\"}]}";

  return fmt::sprintf(kJwtFilterTemplate, Utils::IstioFilterName::kJwt,
                      StringUtil::escape(kJwksInline),
                      StringUtil::escape(kJwksInline));
}

std::string MakeAuthFilterConfig() {
  constexpr char kAuthnFilterWithJwtTemplate[] = R"(
    name: %s
    config:
      policy:
        origins:
        - jwt:
            issuer: https://example.token_service.com
            jwt_headers:
              - ingress-authorization
        principalBinding: USE_ORIGIN
)";
  return fmt::sprintf(kAuthnFilterWithJwtTemplate,
                      Utils::IstioFilterName::kAuthentication);
}

std::string MakeRbacFilterConfig() {
  constexpr char kRbacFilterTemplate[] = R"(
  name: envoy.filters.http.rbac
  config:
    rules:
      policies:
        "foo":
          permissions:
            - any: true
          principals:
            - metadata:
                filter: %s
                path:
                  - key: %s
                value:
                  string_match:
                    exact: %s
)";
  return fmt::sprintf(
      kRbacFilterTemplate, Utils::IstioFilterName::kAuthentication,
      istio::utils::AttributeName::kRequestAuthPrincipal, kExpectedPrincipal);
}

std::string MakeMixerFilterConfig() {
  constexpr char kMixerFilterTemplate[] = R"(
  name: mixer
  config:
    defaultDestinationService: "default"
    mixerAttributes:
      attributes: {
      }
    serviceConfigs: {
      "default": {}
    }
    transport:
      attributes_for_mixer_proxy:
        attributes: {
          "source.uid": {
            string_value: %s
          }
        }
      report_cluster: %s
      check_cluster: %s
  )";
  return fmt::sprintf(kMixerFilterTemplate, kSourceUID, kTelemetryBackend,
                      kPolicyBackend);
}

class ExchangedTokenIntegrationTest : public HttpProtocolIntegrationTest {
 public:
  void createUpstreams() override {
    HttpProtocolIntegrationTest::createUpstreams();
    fake_upstreams_.emplace_back(new FakeUpstream(
        0, FakeHttpConnection::Type::HTTP2, version_, timeSystem()));
    telemetry_upstream_ = fake_upstreams_.back().get();

    fake_upstreams_.emplace_back(new FakeUpstream(
        0, FakeHttpConnection::Type::HTTP2, version_, timeSystem()));
    policy_upstream_ = fake_upstreams_.back().get();
  }

  void SetUp() override {
    config_helper_.addConfigModifier(addNodeMetadata());

    config_helper_.addFilter(MakeMixerFilterConfig());
    config_helper_.addFilter(MakeRbacFilterConfig());
    config_helper_.addFilter(MakeAuthFilterConfig());
    config_helper_.addFilter(MakeJwtFilterConfig());

    config_helper_.addConfigModifier(addCluster(kTelemetryBackend));
    config_helper_.addConfigModifier(addCluster(kPolicyBackend));

    HttpProtocolIntegrationTest::initialize();
  }

  void TearDown() override {
    cleanupConnection(fake_upstream_connection_);
    cleanupConnection(telemetry_connection_);
    cleanupConnection(policy_connection_);
  }

  ConfigHelper::ConfigModifierFunction addNodeMetadata() {
    return [](envoy::config::bootstrap::v2::Bootstrap& bootstrap) {
      ::google::protobuf::Struct meta;
      MessageUtil::loadFromJson(
          fmt::sprintf(R"({
        "ISTIO_VERSION": "1.0.1",
        "NODE_UID": "%s",
        "NODE_NAMESPACE": "%s"
      })",
                       kDestinationUID, kDestinationNamespace),
          meta);
      bootstrap.mutable_node()->mutable_metadata()->MergeFrom(meta);
    };
  }

  ConfigHelper::ConfigModifierFunction addCluster(const std::string& name) {
    return [name](envoy::config::bootstrap::v2::Bootstrap& bootstrap) {
      auto* cluster = bootstrap.mutable_static_resources()->add_clusters();
      cluster->MergeFrom(bootstrap.static_resources().clusters()[0]);
      cluster->mutable_http2_protocol_options();
      cluster->set_name(name);
    };
  }

  void waitForTelemetryRequest(::istio::mixer::v1::ReportRequest* request) {
    AssertionResult result = telemetry_upstream_->waitForHttpConnection(
        *dispatcher_, telemetry_connection_);
    RELEASE_ASSERT(result, result.message());
    result = telemetry_connection_->waitForNewStream(*dispatcher_,
                                                     telemetry_request_);
    RELEASE_ASSERT(result, result.message());

    result = telemetry_request_->waitForGrpcMessage(*dispatcher_, *request);
    RELEASE_ASSERT(result, result.message());
  }

  // Must be called after waitForTelemetryRequest
  void sendTelemetryResponse() {
    telemetry_request_->startGrpcStream();
    telemetry_request_->sendGrpcMessage(::istio::mixer::v1::ReportResponse{});
    telemetry_request_->finishGrpcStream(Grpc::Status::Ok);
  }

  void waitForPolicyRequest(::istio::mixer::v1::CheckRequest* request) {
    AssertionResult result = policy_upstream_->waitForHttpConnection(
        *dispatcher_, policy_connection_);
    RELEASE_ASSERT(result, result.message());
    result =
        policy_connection_->waitForNewStream(*dispatcher_, policy_request_);
    RELEASE_ASSERT(result, result.message());

    result = policy_request_->waitForGrpcMessage(*dispatcher_, *request);
    RELEASE_ASSERT(result, result.message());
  }

  // Must be called after waitForPolicyRequest
  void sendPolicyResponse() {
    policy_request_->startGrpcStream();
    ::istio::mixer::v1::CheckResponse response;
    response.mutable_precondition()->mutable_status()->set_code(Code::OK);
    policy_request_->sendGrpcMessage(response);
    policy_request_->finishGrpcStream(Grpc::Status::Ok);
  }

  void cleanupConnection(FakeHttpConnectionPtr& connection) {
    if (connection != nullptr) {
      AssertionResult result = connection->close();
      RELEASE_ASSERT(result, result.message());
      result = connection->waitForDisconnect();
      RELEASE_ASSERT(result, result.message());
    }
  }

  FakeUpstream* telemetry_upstream_{};
  FakeHttpConnectionPtr telemetry_connection_{};
  FakeStreamPtr telemetry_request_{};

  FakeUpstream* policy_upstream_{};
  FakeHttpConnectionPtr policy_connection_{};
  FakeStreamPtr policy_request_{};
};

INSTANTIATE_TEST_SUITE_P(
    Protocols, ExchangedTokenIntegrationTest,
    testing::ValuesIn(HttpProtocolIntegrationTest::getProtocolTestParams()),
    HttpProtocolIntegrationTest::protocolTestParamsToString);

TEST_P(ExchangedTokenIntegrationTest, ValidExchangeToken) {
  codec_client_ =
      makeHttpConnection(makeClientConnection((lookupPort("http"))));

  // A valid exchanged token in the header for an exchanged token
  auto response = codec_client_->makeHeaderOnlyRequest(
      HeadersWithToken(kHeaderForExchangedToken, kExchangedToken));

  ::istio::mixer::v1::CheckRequest check_request;
  waitForPolicyRequest(&check_request);
  // Check request should see the authn attributes in the original payload.
  EXPECT_THAT(
      check_request.attributes().words(),
      ::testing::AllOf(Contains(kDestinationUID), Contains("10.0.0.1"),
                       Contains(kExpectedPrincipal), Contains("sub"),
                       Contains("example-subject"), Contains("iss"),
                       Contains("https://accounts.example.com"),
                       Contains("email"), Contains("user@example.com")));
  sendPolicyResponse();

  waitForNextUpstreamRequest(0);
  // Send backend response.
  upstream_request_->encodeHeaders(Http::TestHeaderMapImpl{{":status", "200"}},
                                   true);
  response->waitForEndStream();

  // Report is sent after the backend responds.
  ::istio::mixer::v1::ReportRequest report_request;
  waitForTelemetryRequest(&report_request);
  // Report request should also see the same authn attributes.
  EXPECT_THAT(
      report_request.default_words(),
      ::testing::AllOf(Contains(kDestinationUID), Contains("10.0.0.1"),
                       Contains(kExpectedPrincipal), Contains("sub"),
                       Contains("example-subject"), Contains("iss"),
                       Contains("https://accounts.example.com"),
                       Contains("email"), Contains("user@example.com")));

  sendTelemetryResponse();

  EXPECT_TRUE(response->complete());
  EXPECT_EQ("200", response->headers().Status()->value().getStringView());
}

TEST_P(ExchangedTokenIntegrationTest, ValidExchangeTokenAtWrongHeader) {
  codec_client_ =
      makeHttpConnection(makeClientConnection((lookupPort("http"))));

  // When a token is not in the header for an exchanged token,
  // it will not be regarded as an exchanged token.
  auto response = codec_client_->makeHeaderOnlyRequest(
      HeadersWithToken("wrong-header", kExchangedToken));

  ::istio::mixer::v1::ReportRequest report_request;
  waitForTelemetryRequest(&report_request);
  EXPECT_THAT(report_request.default_words(),
              ::testing::AllOf(Contains(kDestinationUID), Contains("10.0.0.1"),
                               Not(Contains(kExpectedPrincipal))));
  sendTelemetryResponse();

  response->waitForEndStream();
  EXPECT_TRUE(response->complete());
  EXPECT_EQ("401", response->headers().Status()->value().getStringView());
}

TEST_P(ExchangedTokenIntegrationTest, TokenWithoutOriginalClaims) {
  codec_client_ =
      makeHttpConnection(makeClientConnection((lookupPort("http"))));

  // When a token does not contain original_claims,
  // it will be regarded as an invalid exchanged token.
  auto response = codec_client_->makeHeaderOnlyRequest(
      HeadersWithToken(kHeaderForExchangedToken, kTokenWithoutOriginalClaims));

  ::istio::mixer::v1::ReportRequest report_request;
  waitForTelemetryRequest(&report_request);
  EXPECT_THAT(report_request.default_words(),
              ::testing::AllOf(Contains(kDestinationUID), Contains("10.0.0.1"),
                               Not(Contains(kExpectedPrincipal))));
  sendTelemetryResponse();

  response->waitForEndStream();
  EXPECT_TRUE(response->complete());
  EXPECT_EQ("401", response->headers().Status()->value().getStringView());
}

TEST_P(ExchangedTokenIntegrationTest, InvalidExchangeToken) {
  codec_client_ =
      makeHttpConnection(makeClientConnection((lookupPort("http"))));

  // When an invalid exchanged token is in the header for an exchanged token,
  // the request will be rejected.
  auto response = codec_client_->makeHeaderOnlyRequest(
      HeadersWithToken(kHeaderForExchangedToken, "invalid-token"));

  ::istio::mixer::v1::ReportRequest report_request;
  waitForTelemetryRequest(&report_request);
  EXPECT_THAT(report_request.default_words(),
              ::testing::AllOf(Contains(kDestinationUID), Contains("10.0.0.1"),
                               Not(Contains(kExpectedPrincipal))));
  sendTelemetryResponse();

  response->waitForEndStream();
  EXPECT_TRUE(response->complete());
  EXPECT_EQ("401", response->headers().Status()->value().getStringView());
}

}  // namespace
}  // namespace Envoy
